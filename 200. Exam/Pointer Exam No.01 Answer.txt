정답 1. 4Byte 

정답 2. 포인터가 가리키는 데이터의 사이즈가 각각 다르기 때문에(그래서??????)

수정-> 	포인터에 데이터 사이즈에 따라 다음에 가리킬 주소값을 찾아낼 수 있다
	예를 들어 int형 포인터는 4바이트씩 넘어가고 char 와 double은 이와 다르므로
	포인터에도 가리킬 데이터 사이즈에 따른 형태가 필요하다
   

오답(함수내에서 잡은 메모리가 함수 밖으로 나가지 않게 되어 있음) 3. 

boolean char_return(void)
{
	char *arr = (char*)malloc(sizeof(char)*16);
	
	if(arr==NULL)
		return -1;
		
	else
		return true;

}

char* char_return(void)
{
	char *arr = (char*)malloc(sizeof(char)*16);
	
	if(arr==NULL)
		return -1;
		
	else
		return arr;

}


정답 4. 동작이 가능하다  pszBuffer는 1차원 배열로 볼 수 있기 때문
   pszBuffer[1~26] 에는 알파벳이 순서대로 저장될 것이다



오답(문자열 크기와 메모리 크기가 일치하지 않음) 5.

->수정

	char* arr=(char*)malloc(sizeof(char)*20);
	gets(arr);     //input string : this exam is very easy!

	arr[20]='\0';
	puts(arr);


오답 6.


->수정
	//matrix[5][10]
	char **matrix = (char**)malloc((5)*sizeof(char*));

	for(int i = 0;i<5;i++)
		matrix[i] = (char*)malloc((10)*sizeof(char));
	
오답(잘 생각해 보길...) 7. 
->수정
	김호승???
